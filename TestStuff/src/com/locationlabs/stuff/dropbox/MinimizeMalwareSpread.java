package com.locationlabs.stuff.dropbox;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Created by manjeet.singh on 7/23/19.
 */
public class MinimizeMalwareSpread {
   private static int minMalwareSpread(int[][] graph, int[] initial) {
      if (graph == null || initial == null || graph.length == 0 || initial.length == 0) {
         return 0;
      }

      // sort the inital array, this is so we can break the tie with the smallest node position if there is a tie
      Arrays.sort(initial);
      final Set<Integer> malwares = IntStream.of(initial).boxed().collect(Collectors.toSet());

      int max = Integer.MIN_VALUE;
      int result = initial[0];
      for (int infected : initial) {
         boolean[] containsInfectedNeighbor = new boolean[1];
         // how number of nodes in the current union
         int count = dfs(infected, infected, graph, new HashSet<>(), malwares, containsInfectedNeighbor);
         // if current union has another malware,
         // which means if we delete current node,
         // still another malware will affect the whole union
         if (containsInfectedNeighbor[0]) {
            continue;
         }
         if (count > max) {
            max = count;
            result = infected;
         }
      }

      return result;
   }

   private static int dfs(int start, int initial, int[][] graph, Set<Integer> visited, Set<Integer> malwares,
                          boolean[] containsInfectedNeighbor) {
      if (visited.contains(start) || containsInfectedNeighbor[0]) {
         return 0;
      }


      int count = 1;
      visited.add(start);
      for (int i = 0; i < graph[start].length; i++) {
         if (graph[start][i] == 1) {
            // if we found another malware that is different from the initialStart,
            // we set the flag to true and there is no need to continue the search.
            if (initial != i && malwares.contains(i)) {
               containsInfectedNeighbor[0] = true;
               break;
            }
            count += dfs(i, initial, graph, visited, malwares, containsInfectedNeighbor);
         }
      }
      return count;
   }

   public static void main(String[] args) {
      System.out.println(minMalwareSpread(new int[][]{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, new int[]{0, 1}));
      System.out.println(minMalwareSpread(new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, new int[]{0, 2}));
      System.out.println(minMalwareSpread(new int[][]{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, new int[]{1, 2}));
   }
}
